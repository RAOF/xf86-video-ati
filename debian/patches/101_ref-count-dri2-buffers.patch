commit 823232d79211832e770c72b027b229950740605d
Author: Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
Date:   Tue Aug 17 12:13:09 2010 +1000

    dri2: Reference-count DRI2 buffers.
    
    When a client calls ScheduleSwap we set up a kernel callback when the
    relevent vblank event occurs.  However, it's possible for the client
    to go away between calling ScheduleSwap and the vblank event,
    resulting in the buffers being destroyed before they're passed to
    radeon_dri2_frame_event_handler.
    
    Add reference-counting to the buffers and take a reference in
    radeon_dri2_schedule_swap to ensure the buffers won't be destroyed
    before the vblank event is dealt with.
    
    Fixes: http://bugs.freedesktop.org/show_bug.cgi?id=29065
    Signed-off-by: Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>

Index: xserver-xorg-video-ati/src/radeon_dri2.c
===================================================================
--- xserver-xorg-video-ati.orig/src/radeon_dri2.c	2010-08-26 12:58:57.886218003 +1000
+++ xserver-xorg-video-ati/src/radeon_dri2.c	2010-08-26 12:59:46.000000000 +1000
@@ -55,6 +55,7 @@
 struct dri2_buffer_priv {
     PixmapPtr   pixmap;
     unsigned int attachment;
+    unsigned int refcnt;
 };
 
 
@@ -220,6 +221,7 @@
     buffers->flags = 0; /* not tiled */
     privates->pixmap = pixmap;
     privates->attachment = attachment;
+    privates->refcnt = 1;
 
     return buffers;
 }
@@ -251,13 +253,26 @@
     if(buffers)
     {
         ScreenPtr pScreen = drawable->pScreen;
-        struct dri2_buffer_priv *private;
+        struct dri2_buffer_priv *private = buffers->driverPrivate;
 
-        private = buffers->driverPrivate;
-        (*pScreen->DestroyPixmap)(private->pixmap);
+        /* Trying to free an already freed buffer is unlikely to end well */
+        if (private->refcnt == 0) {
+            ScrnInfoPtr scrn = xf86Screens[pScreen->myNum];
 
-        free(buffers->driverPrivate);
-        free(buffers);
+            xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                       "Attempted to destroy previously destroyed buffer.\
+ This is a programming error\n");
+            return;
+	}
+
+        private->refcnt--;
+        if (private->refcnt == 0)
+        {
+            (*pScreen->DestroyPixmap)(private->pixmap);
+
+            free(buffers->driverPrivate);
+            free(buffers);
+        }
     }
 }
 #endif
@@ -348,6 +363,20 @@
     DRI2BufferPtr back;
 } DRI2FrameEventRec, *DRI2FrameEventPtr;
 
+static void
+radeon_dri2_ref_buffer(BufferPtr buffer)
+{
+    struct dri2_buffer_priv *private = buffer->driverPrivate;
+    private->refcnt++;
+}
+
+static void
+radeon_dri2_unref_buffer(BufferPtr buffer)
+{
+    struct dri2_buffer_priv *private = buffer->driverPrivate;
+    radeon_dri2_destroy_buffer(&(private->pixmap->drawable), buffer);
+}
+
 void radeon_dri2_frame_event_handler(unsigned int frame, unsigned int tv_sec,
                                      unsigned int tv_usec, void *event_data)
 {
@@ -363,6 +392,8 @@
     status = dixLookupDrawable(&drawable, event->drawable_id, serverClient,
                                M_ANY, DixWriteAccess);
     if (status != Success) {
+        radeon_dri2_unref_buffer(event->front);
+        radeon_dri2_unref_buffer(event->back);
         free(event);
         return;
     }
@@ -394,6 +425,8 @@
         break;
     }
 
+    radeon_dri2_unref_buffer(event->front);
+    radeon_dri2_unref_buffer(event->back);
     free(event);
 }
 
@@ -618,6 +651,13 @@
 
     swap_info = calloc(1, sizeof(DRI2FrameEventRec));
 
+    /* radeon_dri2_frame_event_handler will get called some unknown time in the
+     * future with these buffers.  Take a reference to ensure that they won't
+     * get destroyed before then.
+     */
+    radeon_dri2_ref_buffer(front);
+    radeon_dri2_ref_buffer(back);
+
     /* Drawable not displayed... just complete the swap */
     if (crtc == -1 || !swap_info)
         goto blit_fallback;
@@ -752,6 +792,10 @@
     DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
     if (swap_info)
         free(swap_info);
+
+    radeon_dri2_unref_buffer(front);
+    radeon_dri2_unref_buffer(back);
+
     *target_msc = 0; /* offscreen, so zero out target vblank count */
     return TRUE;
 }
